<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>BoxProver Guide</title>
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,700italic,400italic,700' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700"/>
    <script type="text/javascript" charset="utf-8" src="ace/src-min/ace.js"></script>
    <link rel="stylesheet" type="text/css" href="elusive-icons/css/elusive-icons.css" />
    <link rel="stylesheet" type="text/css" href="boxproof.css" />
    <link rel="stylesheet" type="text/css" media="print" href="print.css" />
    <script src="jquery-1.11.3.min.js"></script>
    <script>
      function openExample()
      {
        var proof = $(this).parents('tr').find('pre').text();
        var url = "/index.html?proof=" + encodeURIComponent(proof);
        window.open(url);
      }
      $().ready(function() {
        $('.open-example').click(openExample);
      });
    </script>
    <style>
      html {
      box-sizing: border-box;
      }
      
      *, *:before, *:after {
      box-sizing: inherit;
      }
      
      body {
      font-family: Helvetica, Arial, FreeSans, sans-serif;
      }

      #main {
      width: 800px;
      margin-left: auto;
      margin-right: auto;
      }

      table {
      margin-left: auto;
      margin-right: auto;
      page-break-inside: avoid;
      }

      .hrrule {
      font-family: 'Doid Sans';
      font-style: italic;
      }

      pre, .bprule {
      font-family: 'Source Code Pro';
      }

      #ruletable pre, .example-table pre {
      margin:0;
      background-color: #eef;
      padding:5px;
      }

      #ruletable , table.simple-table {
      border-collapse: collapse;
      }
      
      #ruletable tr , table.simple-table tr {
      border-bottom: 1px solid #ccc;
      }

      #ruletable tr:first-child , table.simple-table tr:first-child {
      border-bottom: 2px solid black;
      font-weight: bold;
      }

      #ruletable tr:last-child , table.simple-table tr:last:child {
      border-bottom: none;
      }
      
      #ruletable td , table.simple-table td {
      padding: 6px 15px;
      }

      .open-example {
      cursor: pointer;
      }

      .output {
      padding-left:1em;
      background-color: #ffd;
      color: 333;
      }

      .highlight {
      font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="main">
      <h1>BoxProver Guide</h1>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#tutorial">Tutorial</a>
          <ul>
            <li><a href="#a-simple-example">A simple example</a></li>
            <li><a href="#temporary-assumptions">Temporary assumptions</a></li>
            <li><a href="#interactive-proving">Interactive proving</a></li>
            <li><a href="#advanced-holes">Advanced holes</a></li>
          </ul>
        </li>
        <li><a href="#syntax-reference">Syntax</a>
          <ul>
            <li><a href="#variables">Variables</a></li>
            <li><a href="#formulas">Formulas</a></li>
            <li><a href="#sequents">Sequents</a></li>
            <li><a href="#proofs">Proofs</a>
              <ul>
                <li><a href="#proof-lines">Proof lines</a></li>
                <li><a href="#assumptions">Assumptions/premises</a></li>
                <li><a href="#boxes">Boxes</a></li>
                <li><a href="#chaining">Chaining proofs together</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#rule-reference">Rule reference</a></li>
        <li><a href="#idioms">Idioms and avanced usage</a>
          <ul>
            <li><a href="#lemmas">Lemmas</a></li>
          </ul>
        </li>
      </ul>
      
      <h2><a name="introduction" href="#introduction">Introduction</a></h2>
      <p>
        BoxProver is a userfriendly front-end to the <a href="http://twelf.org/">Twelf</a> proof assistant, and provides a simple way to encode and verify natural deduction proofs in propositional and first-order logic using Fitch-style notation. Although all proofs will be specified in the language of Twelf, no knowledge of this language is required from the user. Besides verification, BoxProver also has facilities for producing visual representations of proofs, closely following the style and notation of the book <a href="http://www.cs.bham.ac.uk/research/projects/lics/">Logic in Computer Science, 2nd edition</a> by Huth &amp; Ryan (henceforth referred to as H&amp;R).
      </p>

      <p>
        The following section gives a quick crash-course in BoxProver. If this is the first time you are using BoxProver, start by reading that. The sections on <a href="#syntax-reference">syntax</a> and <a href="#rule-reference">rules</a> contains details on the syntactic structure and proof rules.
      </p>
      
      <h1><a name="tutorial" href="#tutorial">Tutorial</a></h1>

      <p>
        Every BoxProver script must follow this general format:
      </p>

      <table class="example-table">
        <tr>
          <td>
<pre>%abbrev
<i>proof_name</i> : {p1}{p2} ... {pn} proof ( <i>... sequent ...</i> ) =
[p1][p2] ... [pn]

 <i>... proof body ...</i>

.
</pre>
          </td>
        </tr>
      </table>

      <p>This will declare a proof named <i>proof_name</i> which proves a given sequent about propositions <i>p₁</i>, <i>p₂</i>, ..., <i>p<sub>n</sub></i>. We will explain this in more detail in the following using a concrete example.</p>
      
      <h2><a name="a-simple-example" href="#a-simple-example">A simple example</a></h2>
      <p>
        Let us consider Example 1.6 from H&amp;R:
      </p>

<table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="par">(</span><span class="pred">p</span><span class="op"> ∧ </span><span class="pred">q</span><span class="par">)</span><span class="op"> ∧ </span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">2</td><td class="conc "><span class="pred">s</span><span class="op"> ∧ </span><span class="pred">t</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">3</td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="pred">q</span></td><td class="rule ">∧e₁ 1</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">4</td><td class="conc "><span class="pred">q</span></td><td class="rule ">∧e₂ 3</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">5</td><td class="conc "><span class="pred">s</span></td><td class="rule ">∧e₁ 2</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">6</td><td class="conc "><span class="pred">q</span><span class="op"> ∧ </span><span class="pred">s</span></td><td class="rule ">∧i 4, 5</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>

      <p>The box proof above has been produced by BoxProver from the following formal proof script (click the button on the right to open the script in BoxProver):</p>
      <table class="example-table">
        <tr>
          <td>
<pre>%abbrev
ex1-6 : {p}{q}{r}{s}{t}
        proof ((p /\ q) /\ r , s /\ t , |- q /\ s) =
[p][q][r][s][t]
(p /\ q) /\ r       assumption;    [l1]
s /\ t              assumption;    [l2]
p /\ q              by con_e1 l1 ; [l3]
q                   by con_e2 l3 ; [l4]
s                   by con_e1 l2 ; [l5]
q /\ s              by con_i l4 l5
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        The proof script language is intentionally designed to resemble Fitch-style notation as much as possible. As can be seen, the proof script is also written line-by-line with a formula on each line accompanied by the rule justifying it. Unlike Fitch-proofs, lines are not referenced by their number, but are instead given a name. The names are written in square brackets in the rightmost column, and are intentionally chosen to resemble the original line numbering scheme.</p>
      <p>
        The <code>%abbrev</code> declaration on the first line is required by Twelf and is unrelated to the proof that we are formalizing. It changes the way Twelf does type-checking and is required when we want to develop proofs in a more interactive fashion. For this particular example we can actually remove it, but since it never results in an error to include it, it is safest just to keep it in all your proofs.
      </p>
      <p>
        The formal proof language require that we explicitly write down the sequent that we want to prove as well as the names of all propositions that we will be referring to. This information is provided in the preamble in lines 2-4. Line 2 defines the name of our proof to be <code>ex1-6</code> and defines the names <code>p, q, r, s, t</code> as propositions such that they can be used in the statement of the proof sequent in Line 3. Each name must be put in curly braces, and BoxProver figures out by itself that each name stands for a proposition based on how it is used. A more verbose, but equivalent, way to express the same would be by the line <pre style="text-align: center;">{p:prop}{q:prop}{r:prop}{s:prop}{t:prop}</pre> Line 3 defines the proof <i>type</i> using the operator <code>proof</code> followed by an encoding of the sequent <center style="margin:1em;"><i>(p ∧ q) ∧ r , s ∧ t ⊢ q ∧ s.</i></center> This is encoded as a list of formulas separated by <code>,</code> with the last formula (the conclusion) prefixed by <code>|-</code>. The last formula is the conclusion, and all previous formulas make up the premises.</p>
      <p>
        The sequent is followed by an equals sign which marks the beginning of the proof body. The first thing we must do in the proof body is to repeat the declarations of the propositions that we intend to use, but this time enclosed in square brackets instead of curly braces. Then follows the actual proof body which is terminated by a single dot (<code>.</code>).
      </p>

      <p>
        A proof line is justified either by an <i>introduction rule</i> or a <i>general rule</i>. The rule <code>assignment;</code> (note that the semicolon is part of the name) is an introduction rule, and requires that the line it appears on is given a name. The meaning of the rule is to take an assumption from the list of premises and make it available to the rest of the proof body. The line <pre style="text-align:center;">p /\ q by con_e1 l1</pre> is an example of a general rule, which must always begin with the keyword <code>by</code> followed by a rule name followed by a number of line references to previous lines.
      </p>

      <p>
        Proof lines are combined using the <code>;</code> (semicolon) operator. The semicolon <i>must</i> be surrounded by whitespace and be followed by a line name enclosed in square brackets. This has the effect of giving a name to the conclusion of the rule to the left, which can then be referenced by later rules.
      </p>

      <h2><a name="temporary-assumptions" href="#temporary-assumptions">Temporary assumptions</a></h2>
      <p>
        Fitch-proofs uses boxes to demarcate temporary assumptions. The BoxProver encoding of temporary assumptions also closely resemble the Fitch notation, which we will demonstrate with another example. Consider Example 1.14 from H&amp;R:
      </p>

      <table class="example-table">
        <tr>
          <td><table class="boxproof"><tbody><tr><td class="line">1</td><td class="box "></td><td class="conc "><span class="pred">p</span><span class="op"> → </span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">2</td><td class="box active open"></td><td class="conc open"><span class="pred">p</span><span class="op"> ∧ </span><span class="pred">q</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">3</td><td class="box active "></td><td class="conc "><span class="pred">p</span></td><td class="rule ">∧e₁ 2</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">4</td><td class="box active "></td><td class="conc "><span class="pred">q</span></td><td class="rule ">∧e₂ 2</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">5</td><td class="box active "></td><td class="conc "><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">→e 3, 1</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">6</td><td class="box active close"></td><td class="conc close"><span class="pred">r</span></td><td class="rule close">→e 4, 5</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">7</td><td class="box "></td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">→i 2-6</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-14 : {p}{q}{r}
  proof (p => (q => r)
        , |- p /\ q => r) =
[p][q][r]
p => (q => r)   premise; [@prem]
(   p /\ q      assumption; [@assump]
    p           by con_e1 @assump ; [@p]
    q           by con_e2 @assump ; [@q]
    q => r      by imp_e @p @prem ; [@qr]
    r           by imp_e @q @qr
)               ; [#box]
p /\ q => r     by imp_i #box.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        Local assumptions are simply represented by parentheses, with the caveat that the closing parenthesis must be followed by a semicolon and a name in brackets. All line references introduced inside the parentheses are invisible outside the parentheses (effictively introducing a <i>nested scope</i> similarly to scoping in programming languages), including the assumption made on Line 2. The name <code>#box</code> becomes a reference to the whole box and can be used in rules expecting a "box" premise.
      </p>

      <p>
        To understand precisely how line references work, it might be instructive to see how the fully annotated proof script looks. This assigns a <i>"type"</i> to every line reference which is used to check that it is used correctly:
      </p>
      <table class="example-table">
        <tr>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-14 : {p}{q}{r}
  proof (p => (q => r)
        , |- p /\ q => r) =
[p][q][r]
p => (q => r) premise;            [@prem   : ref (|- p => q => r)]
(   p /\ q    assumption;         [@assump : ref (|- p /\ q)]
    p         by con_e1 @assump ; [@p      : ref (|- p)]
    q         by con_e2 @assump ; [@q      : ref (|- q)]
    q => r    by imp_e @p @prem ; [@qr     : ref (|- q => r)]
    r         by imp_e @q @qr
)             ;                   [#box    : ref (p /\ q , |- r)]
p /\ q => r   by imp_i #box.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>
      <p>
        Note that every reference is typed by a <i>sequent</i> which for every single-line reference has no premises, and which for the "box" reference has a single premise. That is, the annotation <code>#box : ref (p /\ q , |- r)</code> indicates that lines 2 to 6 forms a valid proof of the sequent <i>p ∧ q ⊢ r</i>.
      </p>

      <h2><a name="interactive-proving" href="#interactive-proving">Interactive proving</a></h2>
      <p>
        If you are writing a large proof, you may want to check if your steps up until now are sound. BoxProver allows you to do this by providing a partial proof with "holes" in it. The system will accept your partial proof if the steps around the hole are sound and if the all references to the hole are consistent. Furthermore, if BoxProver can infer anything about what formula your hole <i>must</i> prove, it will tell you that information.
      </p>
      <p>
        In order to insert a hole in a proof, you may simply write a single underscore (<code>_</code>) in place of a formula, proof or reference. This is also the easiest way to start a proof and make sure that you have written the proof preamble correctly &mdash; simply insert a hole for the entire proof body and ask BoxProver if the rest is correct. For example, let us encode the proof of Example 1.23 in H&amp;R, which proves the sequent <i>(p ∧ ¬q) → r , ¬r , p ⊢ q</i>. We can thus begin our proof script as follows:
      </p>
      <table class="example-table">
        <tr>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
_
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        If BoxProver accepts this, it means that we did not make any mistakes in the encoding of the sequent. Furthermore, it will render a partial proof that looks as follows:
      </p>
      
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="hole"><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span>, <span class="op">¬</span><span class="pred">r</span>, <span class="pred">p</span> ⊢ <span class="pred">q</span></span></td><td class="rule "><span class="hole">Alpha#1</span></td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>

      <p>
        <code>Alpha#1</code> is an auto-generated name for the hole, and it tells us that we need to prove <i>q</i> using assumptions/premises <i>p ∧ q → r</i>, <i>¬r</i> and <i>p</i>. The red color indicates that the proof is not yet finished. Below the proof, BoxProver will also produce an overview of the local assumptions available to the proof that needs to be filled in for the hole. This is especially useful if you have a large proof and you have lost track of what assumptions you have introduced.
      </p>
      <p>
      Let us go ahead and introduce the three premises, followed by another hole:
      </p>
      <table class="example-table">
        <tr>
          <td>
            <table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">2</td><td class="conc "><span class="op">¬</span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">3</td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">4</td><td class="conc "><span class="hole"><span class="pred">q</span></span></td><td class="rule "><span class="hole">Alpha#1</span></td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
_
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        Success! BoxProver accepted our partial proof and replied with an updated rendering. It also correctly inferred that the only thing that we have left is to show <i>q</i>.
        One way of doing that is to show that <i>¬q</i> would lead to a contradiction, and from that infer that <i>¬¬q</i> must hold. Assuming that we can prove that, the last line of our proof must be an invocation of the <i>¬¬e</i> rule which must make a reference to a proof of <i>¬¬q</i>. Let us use BoxProver to test if that idea will work, and what work we then have left:
      </p>

      <table class="example-table">
        <tr>
          <td>
            <table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">2</td><td class="conc "><span class="op">¬</span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">3</td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">4</td><td class="conc "><span class="pred">q</span></td><td class="rule ">¬¬e <span class="hole">(Ref#1)</span></td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
q                   by nne _
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        In the above, we inserted a hole for a reference instead of a proof. Below the rendered proof, BoxProver will tell us that <code>Ref#1</code> needs to be replaced with a concrete reference to a line concluding <i>¬¬q</i>.
      </p>
      <p>
        Our plan is to show <i>¬¬q</i> using the <i>¬i</i> rule. This rule invocation must be inserted <i>before</i> the application of <i>¬¬e</i>, and it must be given a reference to a <i>box</i> which proves <i>⊥</i> by assuming <i>¬q</i>. We insert this line into our proof and put a hole for the reference:
      </p>

      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">2</td><td class="conc "><span class="op">¬</span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">3</td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">4</td><td class="conc "><span class="op">¬</span><span class="op">¬</span><span class="pred">q</span></td><td class="rule ">¬i <span class="hole">(Ref#1)</span></td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">5</td><td class="conc "><span class="pred">q</span></td><td class="rule ">¬¬e 4</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
~ ~ q               by neg_i _ ;[@n-n-q]
q                   by nne @n-n-q
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        BoxProver will now tell us that <code>Ref#1</code> must be a reference to a proof of the sequent <i>¬q ⊢ ⊥</i>. To produce a proof with an assumption, we need to make a new box. The contents of boxes can also be replaced by holes:
      </p>

      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">2</td><td class="conc "><span class="op">¬</span><span class="pred">r</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">3</td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">4</td><td class="conc "><span class="hole"><span class="op">¬</span><span class="pred">q</span> ⊢ ⊥</span></td><td class="rule "><span class="hole">Alpha#1</span></td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">5</td><td class="conc "><span class="op">¬</span><span class="op">¬</span><span class="pred">q</span></td><td class="rule ">¬i 4</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">6</td><td class="conc "><span class="pred">q</span></td><td class="rule ">¬¬e 5</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
(  _
)                   ; [#box1]  
~ ~ q               by neg_i #box1 ;[@n-n-q]
q                   by nne @n-n-q
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>
      
      <p>
        BoxProver infers that we must prove the sequent <i>¬q ⊢ ⊥</i>, which required that the first line of the box must be an assumption of <i>¬q</i>. We insert that and continue:
      </p>

      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="box "></td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">2</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">3</td><td class="box "></td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">4</td><td class="box active open"></td><td class="conc open"><span class="op">¬</span><span class="pred">q</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">5</td><td class="box active close"></td><td class="conc close"><span class="hole">⊥</span></td><td class="rule close"><span class="hole">Alpha#1</span></td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">6</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="op">¬</span><span class="pred">q</span></td><td class="rule ">¬i 4-5</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">7</td><td class="box "></td><td class="conc "><span class="pred">q</span></td><td class="rule ">¬¬e 6</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
(  ~ q              assumption; [@n-q]
  _
)                   ; [#box1]  
~ ~ q               by neg_i #box1 ;[@n-n-q]
q                   by nne @n-n-q
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        We now need to produce a proof of <i>⊥</i> which will be inserted at line 5. At this point, we can look below the rendered proof to get an overview of the assumptions that will be available to us:
      </p>

<table class="hypotheses"><tbody><tr><td><span class="hole">Alpha#1</span></td><td> : </td><td><span class="metakind">Proof of </span>⊥<div class="context-separator">with premise(s) and assumption(s)&nbsp;<i class="el el-caret-up"></i></div><div class="context"><table class="hypotheses"><tbody><tr><td></td><td></td><td><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td></tr><tr><td></td><td></td><td><span class="op">¬</span><span class="pred">r</span></td></tr><tr><td></td><td></td><td><span class="pred">p</span></td></tr><tr><td></td><td></td><td><span class="op">¬</span><span class="pred">q</span></td></tr></tbody></table></div></td></tr></tbody></table>

      <p>
        As can easily be verified, this just says that all the conclusions at lines 1,2,3 and 4 are available in line 5. Unfortunately the line names are not provided in the current version of BoxProver &mdash; this may change in the future.
      </p>

      <p>
        The last two assumptions can be used to prove the premise of the implication. The implication can then be eliminated to produce <i>r</i>, and finally we can prove <i>⊥</i> since we had <i>¬r</i> as a premise. We fill out the rest of the proof and check that there are no holes left:
      </p>

      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="box "></td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">2</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">3</td><td class="box "></td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">4</td><td class="box active open"></td><td class="conc open"><span class="op">¬</span><span class="pred">q</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">5</td><td class="box active "></td><td class="conc "><span class="pred">p</span><span class="op"> ∧ </span><span class="op">¬</span><span class="pred">q</span></td><td class="rule ">∧i 3, 4</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">6</td><td class="box active "></td><td class="conc "><span class="pred">r</span></td><td class="rule ">→e 5, 1</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">7</td><td class="box active close"></td><td class="conc close">⊥</td><td class="rule close">¬e 6, 2</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">8</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="op">¬</span><span class="pred">q</span></td><td class="rule ">¬i 4-7</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">9</td><td class="box "></td><td class="conc "><span class="pred">q</span></td><td class="rule ">¬¬e 8</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
(  ~ q              assumption; [@n-q]
  p /\ ~ q          by con_i @prem3 @n-q ; [@pnq]
  r                 by imp_e @pnq @prem1 ; [@r]
  bot               by neg_e @r @prem2
)                   ; [#box1]  
~ ~ q               by neg_i #box1 ;[@n-n-q]
q                   by nne @n-n-q
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <h3>Dealing with errors</h3>
      <p>
        While writing the above proof, I accidentally made a reference to <code>@prem2</code> instead of <code>@prem3</code> when trying to prove the formula <code>p /\ ~ q</code>.
      </p>
      
      <table class="example-table">
        <tr>
          <td style="padding-left:20px;">
<pre>%abbrev
ex1-23 : {p}{q}{r}
  proof (p /\ ~ q => r , ~ r , p , |- q) =
[p][q][r]
p /\ ~ q => r       premise; [@prem1]
~ r                 premise; [@prem2]
p                   premise; [@prem3]
(  ~ q              assumption; [@n-q]
                    % The line below is wrong
  p /\ ~ q          by con_i @prem2 @n-q ; [@pnq]
  r                 by imp_e @pnq @prem1 ; [@r]
  bot               by neg_e @r @prem2
)                   ; [#box1]  
~ ~ q               by neg_i #box1 ;[@n-n-q]
q                   by nne @n-n-q
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>
      
      <p>
        Instead of producing a typeset proof, BoxProver will respond with the following error message:
      </p>
      
      <pre class="output">
[Opening file /tmp/twelf-input10599613932089018456]
/tmp/twelf-input10599613932089018456:<span class="highlight">10.24-10.41</span> Error: 
Type mismatch
Expected: <span class="highlight">proof (|- p /\ ~ q)</span>
Inferred: <span class="highlight">proof (|- ~ r /\ ~ q)</span>
Head mismatch
Argument type did not match function domain type
(Index object(s) did not match)
[Closing file /tmp/twelf-input10599613932089018456]
/tmp/twelf-input10599613932089018456:1.2-16.2 Error: 
 1 error found
      </pre>

      <p>
        The error messages are generated by Twelf and may sometimes look cryptic. The above one is very helpful though. It tells us that the error occurred on line 10 in our proof script, and that we accidentally proved the formula <i>¬r ∧ ¬q</i> instead of <i>p ∧ ¬q</i>. Since we have developed our proof interactively, we can just delete what we just wrote and go back to the last working state and try again.
      </p>

      <h2><a name="advanced-holes" href="#advanced-holes">Advanced holes</a></h2>
      <p>
        In the previous example we only inserted holes for proofs whose conclusion was known, and we only inserted one hole at a time. BoxProver allows you to insert <i>any</i> number of holes, however, and it also allows you to insert holes for subproofs that are not referenced anywhere else and whose desired conclusion is hence not known. In the following example, we intend to eliminate the disjunction <i>¬p ∨ q</i>, so we open two boxes which each start assuming one of the disjuncts. We put three holes in the proof, one for each proof in each box, and one for the remainder of the proof:
      </p>
      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="box "></td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">2</td><td class="box "></td><td class="conc "><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">3</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="pred">p</span><span class="op"> ∨ </span><span class="pred">q</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">4</td><td class="box active open"></td><td class="conc open"><span class="op">¬</span><span class="pred">p</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">5</td><td class="box active close"></td><td class="conc close"><span class="hole"><span class="var">Sequent#1</span><span class="par">(</span><span class="var">p</span>, <span class="var">q</span>, <span class="var">r</span>, <span class="var">@p</span>, <span class="var">@qr</span>, <span class="var">@dis</span><span class="par">)</span></span></td><td class="rule close"><span class="hole">Alpha#1</span></td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">6</td><td class="box active open"></td><td class="conc open"><span class="pred">q</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">7</td><td class="box active close"></td><td class="conc close"><span class="hole"><span class="var">Sequent#2</span><span class="par">(</span><span class="var">p</span>, <span class="var">q</span>, <span class="var">r</span>, <span class="var">@p</span>, <span class="var">@qr</span>, <span class="var">@dis</span>, <span class="var">#box1</span><span class="par">)</span></span></td><td class="rule close"><span class="hole">Alpha#2</span></td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">8</td><td class="box "></td><td class="conc "><span class="hole"><span class="pred">r</span></span></td><td class="rule "><span class="hole">Alpha#3</span></td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>
%abbrev
adv-holes : {p}{q}{r}
proof (p , q => r
      , ~ p \/ q , |- r) =
[p][q][r]
p           premise; [@p]
q => r      premise; [@qr]
~ p \/ q    premise; [@dis]
(   ~ p     assumption; [@np]
    _
)           ;[#box1]
(   q       assumption; [@q]
    _
)           ;[#box2]
_
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        Since the two boxes are not used anywhere, BoxProver cannot figure out what they are supposed to prove, and thus inserts generic placeholders called <code>Sequent#1</code> and <code>Sequent#2</code>. The parameters <code>(p, q, r, ...)</code> are lists of propositional variables which the unknown sequents <i>may</i> mention.
      </p>

      <p>
        If we replace the last hole with a correct invocation of the disjunction elimination rule referencing the two boxes, BoxProver will be able to tell us more specific information:
      </p>

      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="box "></td><td class="conc "><span class="pred">p</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">2</td><td class="box "></td><td class="conc "><span class="pred">q</span><span class="op"> → </span><span class="pred">r</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">3</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="pred">p</span><span class="op"> ∨ </span><span class="pred">q</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">4</td><td class="box active open"></td><td class="conc open"><span class="op">¬</span><span class="pred">p</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">5</td><td class="box active close"></td><td class="conc close"><span class="hole"><span class="pred">r</span></span></td><td class="rule close"><span class="hole">Alpha#1</span></td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">6</td><td class="box active open"></td><td class="conc open"><span class="pred">q</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">7</td><td class="box active close"></td><td class="conc close"><span class="hole"><span class="pred">r</span></span></td><td class="rule close"><span class="hole">Alpha#2</span></td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">8</td><td class="box "></td><td class="conc "><span class="pred">r</span></td><td class="rule ">∨e 3, 4-5, 6-7</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr></tbody></table>
          </td>
          <td style="padding-left:20px;">
<pre>
%abbrev
adv-holes : {p}{q}{r}
proof (p , q => r
      , ~ p \/ q , |- r) =
[p][q][r]
p        premise; [@p]
q => r   premise; [@qr]
~ p \/ q premise; [@dis]
(   ~ p  assumption; [@np]
    _
)        ;[#box1]
(   q    assumption; [@q]
    _
)        ;[#box2]
r        by dis_e @dis #box1 #box2
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <h1><a name="syntax-reference" href="#syntax-reference">Syntax</a></h1>
      <p>
        The following is a reference of the general syntactic structure of BoxProver scripts.
      </p>

      <h2><a name="variables" href="#variables">Variables</a></h2>
      <p>
        A variable is an identifier that is not equal to an existing rule name. A valid identifier consists of any sequence of printable non-whitespace characters, except for the following list of <i>reserved symbols</i>:
        <center> <code>. : [ ] { } ( ) </code> </center>
      </p>
      <p>
        This means that BoxProver is very relaxed with regards to what it considers to be a valid identifier. For example, <code>@p\/q=>r</code> is a valid identifier, even though <code>p \/ q => r</code> is a formula. This underlines the fact that <strong>whitespace around operators is very important</strong> to avoid having them interpreted as identifiers.
      </p>
      <p>
        By convention, identifiers generally begin with a lower-case letter, except for so-called <i>meta-variables</i> standing for proof holes which begin with an upper-case letter. For proofs in predicate logic, we will also use upper-case letters for predicates.
      </p>
      <p>
        We recommend the following naming convention to keep your proofs readable:
      </p>
      <table class="simple-table">
        <tr><td>Variable kind</td><td>Convention</td><td>Examples</td></tr>
        <tr>
          <td>Propositions</td>
          <td>Only lower-case</td>
          <td><code>p</code>, <code>q</code>, <code>r</code></td>
        </tr>
        <tr>
          <td>Single-line references</td>
          <td>Prefix with <code>@</code></td>
          <td><code>@1</code>, <code>@7</code>, <code>@q</code>, <code>@q\/p</code></td>
        </tr>
        <tr>
          <td>Multi-line references (i.e. box references)</td>
          <td>Prefix with <code>#</code></td>
          <td><code>#5-9</code>, <code>#box1</code>, <code>#~q-case</code></td>
        </tr>
        <tr>
          <td>First-order predicates</td>
          <td>Single-letter uppercase</td>
          <td><code>P</code>, <code>R</code>, <code>S</code></td>
        </tr>
        <tr>
          <td>First-order terms, constants</td>
          <td>Only lower-case</td>
          <td><code>f</code>, <code>g</code>, <code>c</code></td>
        </tr>
      </table>

      <h2><a name="formulas" href="#formulas">Formulas</a></h2>
      <p>
        Logical connectives are encoded using ASCII imitations of their looks in "real" math notation. The precedence rules match those of H&amp;R, except for first-order quantifiers which require some explicit parentheses. The table below shows how each logical connective is written in BoxProver:
      </p>
      <table class="simple-table">
        <tr>
          <td>H&amp;R</td>
          <td>BoxProver</td>
          <td colspan="3">Example translation</td>
        </tr>
        <tr>
          <td>⊤</td>
          <td><code>top</code></td>
          <td>⊤</td><td>becomes</td><td><code>top</code></td>
        </tr>
        <tr>
          <td>∧</td>
          <td><code>/\</code></td>
          <td><i>(p ∧ q) ∧ r</i></td><td>becomes</td><td><code>(p /\ q) /\ r</code></td>
        </tr>
        <tr>
          <td>∨</td>
          <td><code>\/</code></td>
          <td><i>(p ∨ q) ∨ r</i></td><td>becomes</td><td><code>(p \/ q) \/ r</code></td>
        </tr>
        <tr>
          <td>→</td>
          <td><code>=></code></td>
          <td><i>p → q → r</i></td><td>becomes</td><td><code>p => q => r</code></td>
        </tr>
        <tr>
          <td>¬</td>
          <td><code>~</code></td>
          <td><i>¬¬q</i></td><td>becomes</td><td><code>~ ~ q</code></td>
        </tr>
        <tr>
          <td>⊥</td>
          <td><code>bot</code></td>
          <td>⊥</td><td>becomes</td><td><code>bot</code></td>
        </tr>
        <tr>
          <td>∀x</td>
          <td><code>all ([x] <i> ... </i>)</code></td>
          <td><i>∀x P(x) → ∀y Q(y)</i></td><td>becomes</td><td><code>all ([x] P x) => all ([y] Q y)</code></td>
        </tr>
        <tr>
          <td>∃x</td>
          <td><code>exi ([x] <i> ...</i>)</code></td>
          <td><i>∃x P(x) → ∃y P(y)</i></td><td>becomes</td><td><code>exi ([x] P x) => exi ([y] P y)</code></td>
        </tr>
        <tr>
          <td>=</td>
          <td><code>==</code></td>
          <td><i>f(x,z) = g(y)</i></td><td>becomes</td><td><code>f x z == g y</code></td>
        </tr>
      </table>

      <p>
        Note that all operators <strong>must</strong> be surrounded by white-space, including prefix operators such as negation. For example, <code>~~q</code>, <code>~~ q</code> and <code>~ ~q</code> are not valid, but <code>~ ~ q</code> is.
      </p>
      
      <h2><a name="sequents" href="#sequents">Sequents</a></h2>
      <p>
        Proof sequents are written almost exactly as in H&amp;R, with ⊢ written as <code>|-</code>, but with the caveat that the last premise before the turnstile must be followed by a rather awkward-looking comma. The syntax is best explained by a series of examples:
      </p>
      <table class="simple-table">
        <tr><td>H&amp;R</td><td>BoxProver</td></tr>
        <tr>
          <td>⊢ <i>p</i> → <i>q</i></td>
          <td><code>|- p => q</code></td>
        </tr>
        <tr>
          <td><i>p</i> ⊢ p</td>
          <td><code> p , |- p</code></td>
        </tr>
        <tr>
          <td>¬<i>q</i>, <i>p</i> ∨ <i>q</i> ⊢ <i>p</i></td>
          <td><code>~ q , p \/ q , |- p</code></td>
        </tr>
      </table>

      <p>
        The comma symbol <code>,</code> is actually an operator and <strong>must</strong> be surrounded by whitespace. Remember to put a comma before the turnstile.
      </p>

      <h2><a name="proofs" href="#proofs">Proofs</a></h2>

      <p>
        Proofs in BoxProver are built from a set of primitives which are then composed in order to form larger proofs. Any proof written in BoxProver proves some sequent Φ ⊢ φ, where Φ is a possibly empty list of assumptions and φ is the conclusion of the proof.
      </p>
      <p>
        The smallest proofs we can build are individual <i>proof lines</i> which just consists of a propositional formula and a justifying rule. In order to make larger proofs, we can either use the <i>assumption operator</i> to introduce new assumptions, or combine two proofs with the <i>sequence operator</i>. This will be described in more detail in the following.
      </p>
      
      <h3><a name="proof-lines" href="#proof-lines">Proof lines</a></h3>
      <p>
        Proof lines are the smallest proofs you can write. A single proof line follows the following format:
      </p>
      <center><code><i>formula</i> by <i>rule</i> <i>ref₁</i> <i>ref₂</i> <i>...</i> <i>ref<sub>n</sub></i></code></center>
      <p>
        where <i>formula</i> is a formula, <i>rule</i> is a rule identifier, and <i>ref₁</i> thorugh <i>ref<sub>n</sub></i> are line reference identifiers. Note that line references are separated by whitespace only, no commas or parentheses are required.
      </p>
      <table class="simple-table">
        <tr>
          <td>H&amp;R</td>
          <td>BoxProver</td>
        </tr>
        <tr>
          <td>
            <table>
              <tr><td colspan="3">⋮</td></tr>
              <tr><td><i>k</i></td><td><i>p</i> ∧ <i>q</i></td>
                <td>∧i 3,6</td></tr>
              <tr><td colspan="3">⋮</td></tr>
            </table>
          </td>
          <td>
            <table>
              <tr><td>⋮</td></tr>
              <tr><td><code>p /\ q  by  con_i @3 @6</code></td></tr>
              <tr><td>⋮</td></tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <table>
              <tr><td colspan="3">⋮</td></tr>
              <tr><td>k</td><td><i>p</i> → <i>q</i></td><td>→i 5-9</td></tr>
              <tr><td colspan="3">⋮</td></tr>
            </table>
          </td>
          <td>
            <table>
              <tr><td>⋮</td></tr>
              <tr><td><code>p => q  by  imp_i #5-9</code></td></tr>
              <tr><td>⋮</td></tr>
            </table>
          </td>
        </tr>
      </table>
      
      <h3><a name="assumptions" href="#assumptions">Assumptions/premises</a></h3>
      <p>
        Suppose we have written a proof α which proves a sequent <code><i>φ₁</i> , <i>...</i> , <i>φ<sub>n</sub></i> |- ψ</code> and contains a reference to a proof of <code>|- χ</code> named <code>@ref</code>. The operator <code>assumption;</code> can then be used to turn α into a proof of the sequent <code><i>χ</i>, <i>φ₁</i>, <i>...</i>, <i>φ<sub>n</i> |- ψ</code> as follows:
      </p>
        <pre>
          χ assumption; [@ref]
          α
        </pre>
      <p>
        For a concrete example, let α be equal to the following single-line proof:
      </p>
      <center><code>~ ~ p by nni @p</code></center>
      <p>
        This will be a valid proof <code>α : proof (|- ~ ~ p)</code> if we assume that <code>@p : ref (|- p)</code> is available as an assumption. We can then write
      </p>
      <pre>
        p       assumption; [@p]
        ~ ~ p   by nni @p
      </pre>
      <p>
        to obtain a new proof β where <code>β : proof (p |- ~ ~ p)</code>. We no longer need to assume that there is a reference <code>@p</code> &mdash; β will be a well-formed proof regardless of that.
      </p>
      
      <h3><a name="boxes" href="#boxes">Boxes</a></h3>
      <p>
        A box is simply represented as a proof enclosed in parentheses:
      </p>
      <center><code>( <i>...proof...</i> )</code></center>
      <p>
        This underlines the fact that boxes are merely scoping delimiters as in normal programming language syntax. The proof inside the parentheses can use the assumption operator to introduce assumptions. The mechanism for referring to boxes is the same as that for referring to lines and will be introduced in the next subsection.
      </p>

      <h3><a name="chaining" href="#chaining">Chaining proofs together</a></h3>
      <p>
        Suppose we have produced the following two proofs:
      </p>
      <pre>
          α : proof (Φ |- φ)
          β : proof (Ψ |- χ)
      </pre>
      <p>
        Furthermore, β may depend on a reference <code>@ref : ref (Φ |- φ)</code>. We can apply the <i>chain operator</i> <code>;</code> (semicolon) to connect α and β with each other, producing a new proof <code>γ : proof(|- χ)</code>:
      </p>
      <pre>
        α        ; [@ref]
        β
      </pre>
      <p>
        The new proof <code>γ : proof (Ψ |- χ)</code> will no longer depend on a variable <code>@ref : ref (Φ |- φ)</code>.
      </p>
      <p>
        We illustrate chaining by two concrete examples. For the first example, let α be the proof
      </p>
      <pre>
        top     by top_i
      </pre>
      <p>
        This depends on no references, and we have <code>α : proof (|- top)</code>. We let β be the proof
      </p>
      <pre>
        top /\ top  by con_i @top @top
      </pre>
      <p>
        If we assume that <code>@top : ref (|- top)</code> then we will have <code>β : proof(|- top /\ top)</code>. We can chain together these two proofs to obtain a single proof <code>γ : proof (|- top /\ top)</code> which no longer depends on <code>@ref</code>:
      </p>
      <pre>
        top         by top_i ; [@top]
        top /\ top  by con_i @top @top
      </pre>

      <p>
        For the second example, we will let the first proof use local assumptions. Let <code>α : proof (p , |- ~ ~ p)</code> be the proof
      </p>
      <pre>
      (  p        assumption; [@p]
         ~ ~ p    by nni @p
      )
      </pre>
      <p>
        and, let <code>β : proof (|- p => ~ ~ p)</code> be the proof
      </p>
      <pre>
        p => ~ ~ p  by imp_i #box
      </pre>
      <p>
        We can then chain together the two proofs to obtain a proof <code>(α ; [#box] β) : |- p => ~ ~ p</code> as follows:
      </p>
      <pre>
      (  p        assumption; [@p]
         ~ ~ p    by nni @p
      )           ; [#box]
      p => ~ ~ p  by imp_i #box
      </pre>
      
      <h1><a name="rule-reference" href="#rule-reference">Rule reference</a></h1>
      <p>
        The following is a table showing the BoxProver names for each rule from H&amp;R. Each rule is accompanied by a minimal example showing its use. The examples are also a good way to get familiar with the notation used for formulas/propositions.
      </p>
      
      <table id="ruletable">
        <tr>
          <td>H &amp; R</td><td>BoxProver</td><td>Example</td><td></td>
        </tr>
        <tr><td><span class="hrrule">⊤i</span></td>
          <td><span class="bprule">top_i</span></td>
          <td>
<pre>
ex : proof (|- top) =
top by top_i.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∧i</span></td>
          <td><span class="bprule">con_i</span></td><td>
<pre>
ex : {p}{q} proof (p , q , |- p /\ q) = [p][q]
p      assumption; [l0]
q      assumption; [l1]
p /\ q by con_i l0 l1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∧e₁</span></td>
          <td><span class="bprule">con_e1</span></td><td>
<pre>
ex : {p}{q} proof (p /\ q , |- p) = [p][q]
p /\ q assumption; [l0]
p      by con_e1 l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∧e₂</span></td>
          <td><span class="bprule">con_e2</span></td><td>
<pre>
ex : {p}{q} proof (p /\ q , |- q) = [p][q]
p /\ q assumption; [l0]
q      by con_e2 l0.
</pre>
</td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∨i₁</span></td>
          <td><span class="bprule">dis_i1</span></td><td>
<pre>
ex : {p}{q} proof (p , |- p \/ q) = [p][q]
p      assumption; [l0]
p \/ q by dis_i1 l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∨i₂</span></td>
          <td><span class="bprule">dis_i2</span></td><td>
<pre>
ex : {p}{q} proof (q , |- p \/ q) = [p][q]
q      assumption; [l0]
p \/ q by dis_i2 l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∨e</span></td>
          <td><span class="bprule">dis_e</span></td><td>
<pre>
ex : {p}{q} proof (p \/ q , |- q \/ p) = [p][q]
p \/ q    assumption; [l0]
(  p      assumption; [l1]
   q \/ p by dis_i2 l1
)         ; [case1]
(  q      assumption; [l2]
   q \/ p by dis_i1 l2
)         ; [case2]
q \/ p    by dis_e l0 case1 case2.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">→i</span></td>
          <td><span class="bprule">imp_i</span></td><td>
<pre>
ex : {p} proof (|- p => p) = [p]
(  p    assumption; [l0]
   p    by copy l0
)       ; [case1]
p => p  by imp_i case1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">→e</span></td>
          <td><span class="bprule">imp_e</span></td><td>
<pre>
ex : {p}{q} proof (p , p => q , |- q) = [p][q]
p      assumption; [l0]
p => q assumption; [l1]
q      by imp_e l0 l1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">¬i</span></td>
          <td><span class="bprule">neg_i</span></td><td>
<pre>
ex : {p} proof (p => bot , |- ~ p) = [p]
p => bot    assumption; [l0]
(  p        assumption; [l1]
   bot      by imp_e l1 l0
)           ; [case1]
~ p         by neg_i case1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">¬e</span></td>
          <td><span class="bprule">neg_e</span></td><td>
<pre>
ex : {p} proof (p , ~ p , |- bot) = [p]
p    assumption; [l0]
~ p  assumption; [l1]
bot  by neg_e l0 l1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">⊥e</span></td>
          <td><span class="bprule">bot_e</span></td><td>
<pre>
ex : {p} proof (bot , |- p /\ ~ p) = [p]
bot      assumption; [l0]
p /\ ~ p by bot_e l0.
          </pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">¬¬e</span></td>
          <td><span class="bprule">nne</span></td><td>
<pre>
ex : {p} proof (~ ~ ~ p , |- ~ p) = [p]
~ ~ ~ p  assumption; [l0]
~ p      by nne l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">LEM</span></td>
          <td><span class="bprule">lem</span></td><td>
<pre>
ex : {p} proof (|- p \/ ~ p) = [p]
p \/ ~ p  by lem.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">PBC</span></td>
          <td><span class="bprule">pbc</span></td><td>
<pre>
%abbrev
ex : {p} proof (p , |- p) = [p]
p       assumption; [l0]
(   ~ p assumption; [l1]
    bot by neg_e l0 l1
)       ; [l1-2]
p       by pbc l1-2.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>

        <tr><td><span class="hrrule">¬¬i</span></td>
          <td><span class="bprule">nne</span></td><td>
<pre>
ex : {p} proof (p , |- ~ ~ p) = [p]
p       assumption; [l0]
~ ~ p   by nni l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>

        <tr><td><span class="hrrule">MT</span></td>
          <td><span class="bprule">mt</span></td><td>
<pre>
ex : {p}{q} proof (p => q , ~ q , |- ~ p) = [p][q]
p => q  assumption; [l0]
~ q     assumption; [l1]
~ p     by mt l0 l1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∀i</span></td>
          <td><span class="bprule">all_i</span></td><td>
<pre>
ex : {P} proof (|- all ([x] top \/ P x)) = [P]
(var [x]
   top               by top_i ; [l0]
   top \/ P x        by dis_i1 l0
)                    ; [case1]
all ([x] top \/ P x) by all_i case1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∀e</span></td>
          <td><span class="bprule">all_e</span></td><td>
<pre>
ex : {P}{t} proof (all ([x] P x) , |- P t) = [P][t]
all ([x] P x)  assumption; [l0]
P t            by all_e t l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∃i</span></td>
          <td><span class="bprule">exi_i</span></td><td>
<pre>
ex : {P} proof (tm [t] P t , |- exi ([x] P x)) = [P]
var[t]
P t           assumption; [l0]
exi ([x] P x) by exi_i t l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">∃e</span></td>
          <td><span class="bprule">exi_e</span></td><td>
<pre>
ex : {P} proof (all ([x] P x) , exi ([y] ~ P y)
                              , |- bot) = [P]
all ([x] P x)    assumption; [l0]
exi ([y] ~ P y)  assumption; [l1]
(var[z]
   ~ P z         assumption; [l2]
   P z           by all_e z l0 ; [l3]
   bot           by neg_e l3 l2
)                ; [case1]
bot              by exi_e l1 case1.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">=i</span></td>
          <td><span class="bprule">eq_i</span></td><td>
<pre>
ex : {t:term} proof (|- t == t) = [t]
t == t  by eq_i.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
        <tr><td><span class="hrrule">=e</span></td>
          <td><span class="bprule">eq_e</span></td><td>
<pre>
ex : {s}{t}{P} proof (s == t , P s , |- P t) =
[s][t][P]
s == t  assumption; [l0]
P s     assumption; [l1]
P t     by eq_e ([x] P x) l1 l0.
</pre></td><td><span class="open-example el el-circle-arrow-right"></span></td></tr>
      </table>

      <h1><a name="idioms" href="#idioms">Idioms and advanced usage</a></h1>

      <h2><a name="lemmas" href="#lemmas">Lemmas</a></h2>
      <p>
        BoxProver has limited support for defining lemmas, that is, proof blocks that can be reused later in other proofs.
      </p>
      <p>
        For example, suppose that our proof system came without the PBC rule. We would then like to prove PBC <i>as a theorem</i> which we can then refer to in place of the actual rule. The effect of this is that the PBC theorem gets "inlined" for every invocation, effectively making its use invisible in the final proof.
      </p>
      <p>
        For technical reasons, BoxProver cannot inline a proof of a sequent. Instead, we must formulate a lemma as a proof which has explicit, named holes for its premises. Whenever we want to use the lemma we must provide it with concrete references which can be inserted. For example, the PBC lemma looks as follows:
      </p>

      <table class="example-table">
        <tr>
          <td>
<table class="boxproof"><tbody><tr><td class="line">1</td><td class="conc "><span class="op">¬</span><span class="op">¬</span><span class="pred">p</span></td><td class="rule ">¬i (@ref)</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr><tr><td class="line">2</td><td class="conc "><span class="pred">p</span></td><td class="rule ">¬¬e 1</td></tr><tr class="empty"><td class="line"> </td><td class="conc"> </td><td class="rule"> </td></tr></tbody></table>
          </td>
          <td>
<pre>%abbrev
pbc-lemma : {p}
  ref (~ p , |- bot) -> proof (|- p) =
[p][@ref]
~ ~ p           by neg_i @ref ; [@nnp]
p               by nne @nnp
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        BoxProver will tell us that we have proved the following:
      </p>
      <p>
        <center><span class="metaquantifier">for all </span><span class="var">p</span> , <span class="par">(</span><span class="op">¬</span><span class="pred">p</span> ⊢ ⊥<span class="par">)</span> <span class="cdots">⋯</span><span class="pred">p</span></center>
        </p>
      
      <p>
        This should be read as follows: "for all propositions p, if there is a proof of (¬p ⊢ ⊥) then there is a proof of ⊢ p".
      </p>

      <p>
        The lemma can be used in all proofs declared after it. Simply begin a new proof (remember to prefix it with <code>%abbrev</code>!) and use the lemma as an ordinary rule:
      </p>

      <table class="example-table">
        <tr>
          <td>
            <table class="boxproof"><tbody><tr><td class="line">1</td><td class="box "></td><td class="conc "><span class="pred">q</span></td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">2</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="pred">p</span><span class="op"> ∧ </span><span class="pred">q</span><span class="op"> → </span>⊥</td><td class="rule ">premise </td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">3</td><td class="box active open"></td><td class="conc open"><span class="op">¬</span><span class="pred">p</span></td><td class="rule open">assumption </td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">4</td><td class="box active "></td><td class="conc "><span class="op">¬</span><span class="pred">p</span><span class="op"> ∧ </span><span class="pred">q</span></td><td class="rule ">∧i 3, 1</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box active"> </td><td class="conc"> </td><td class="rule"> </td><td class="box active"> </td></tr><tr><td class="line">5</td><td class="box active close"></td><td class="conc close">⊥</td><td class="rule close">→e 4, 2</td><td class="box active"></td></tr><tr class="empty"><td class="line"> </td><td class="box"> </td><td class="conc"> </td><td class="rule"> </td><td class="box"> </td></tr><tr><td class="line">6</td><td class="box "></td><td class="conc "><span class="op">¬</span><span class="op">¬</span><span class="pred">p</span></td><td class="rule ">¬i 3-5</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr><tr><td class="line">7</td><td class="box "></td><td class="conc "><span class="pred">p</span></td><td class="rule ">¬¬e 6</td><td class="box "></td></tr><tr class="empty"><td class="line"> </td><td class="box"></td><td class="conc"> </td><td class="rule"> </td><td class="box"></td></tr></tbody></table>
          </td>
          <td>
<pre>
%abbrev
pbc-lemma : {p}
  ref (~ p , |- bot) -> proof (|- p) =
[p][@ref]
~ ~ p           by neg_i @ref ; [@nnp]
p               by nne @nnp
.
%abbrev
lemma-example : {p}{q}
  proof (q , (~ p) /\ q => bot , |- p) =
[p][q]
q               premise; [@q]
~ p /\ q => bot premise; [@imp]
(   ~ p         assumption; [@np]
    ~ p /\ q    by con_i @np @q ; [@con]
    bot         by imp_e @con @imp
)               ; [#box]
p               by pbc-lemma p #box
.
</pre>
          </td>
          <td><span class="open-example el el-circle-arrow-right"></span></td>
        </tr>
      </table>

      <p>
        As a caveat, note that <code>pbc-lemma</code> as a rule takes <i>two</i> arguments: the first is the formula which will take the place for the propositional variable <code>p</code>, and the second is a reference to a box proving <code>bot</code> from <code>~ p</code>. You may replace the first argument with an underscore, since it can almost always be inferred uniquely from the reference.
      </p>
    </div>
  </body>
</html>
